<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-2</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Initialize Patron Variables

//Group size of patrons (default)
group_size = 1;

//Type of patron (set in child)
// 0 = male
// 1 = female
patron_type = noone;

//Depth
orig_depth = -2;
depth = orig_depth;

//Table ID (used so that the patron can access table state and position values)
table_id = noone;

//Default base_points (can be altered in child)
base_points = 200;

//Happiness (Maximum happiness to start with)
happiness = 6;
//How many seconds it takes for happiness to decay
happiness_decay = 5;
//Initialize the happiness timer used in the step event
happiness_timer = room_speed * happiness_decay;

//Time (in seconds) to decide on game
wait_time = 6;
//Time (in seconds) it takes for patrons to play the game
playing_game_time = 7;

//Used in the drag/drop in the step event
selected = false;
seated = false;
//Used to makesure the player can't interact with the patrons if they are already leaving
leaving = false;

//Play the sound when they are first created
scr_play_sound(s_footsteps);
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite related variables

enum patron { 
    standing = 0,
    sitting = 1,
    hand = 2,
    waiting = 3,
    game = 4,
    leaving = 5
}

//Patron sprite state values
// 0 = standing
// 1 = sitting
// 2 = hand
// 3 = waiting
// 4 = game
// 5 = leaving
patron_state = patron.standing;

//The sprite indexes for these values
spr_standing = noone;       //State 0
spr_sitting_front = noone;  //State 1
spr_sitting_back = noone;   //State 1
spr_hand_front = noone;     //State 2
spr_hand_back = noone;      //State 2
spr_waiting_front = noone;  //State 3
spr_waiting_back = noone;   //State 3
spr_game_front = noone;     //State 4
spr_game_back = noone;      //State 4

//Image and speed variables, see draw event for controller
spr_subimage = 0; //Curent subimage to be drawn
spr_image_speed = 10; //How many steps until change image (in steps not seconds)
spr_image_speed_counter = 0;//The counter that will count up to the image speed above

spr_width = noone; //Set in children. Used to place patrons in queue next to eachother.

sprite_index = spr_patron_standing_box; //Set this as sprite index so patron can be clicked and dragged
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Audio related variables

snd_ready = noone;
snd_leave = noone;
snd_leave_happy = noone;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="3">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Done with game alarm
scr_play_sound(snd_ready);

patron_state = patron.hand;

with(table_id) {
    is_waiting = true;
    table_state = 4;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Patron Leaves

//If patron is in the queue
if(!seated) {
    //With the queue
    with(obj_queue) {
        //Find the position of the patron in the queue
        var pos = ds_list_find_index(patron_queue, other.id);
        //Remove that position from the queue
        ds_list_delete(patron_queue, pos);
        //Reorder the queue
        alarm[1] = 1;
    }
}

with(table_id) {
    //If the table has a game to be delivered
    if(table_state == 2) {
        //We will use the found_game variable (from create event) to record whether or not we found 
        //the correct game (table_number) (Forced to use instance variable instead of local variable 
        //due to conflicts with the 'other' keyword not working properly.)

        //In the cart object
        with(global.cart_id) {
            //First check if the counters have the game
            //If they do, clear the counter of the game (and it will exit the rest of the if's)
            if(counter_left.val == other.table_number) {
                counter_left.val = -1;
                other.found_game = true;
            } else if (counter_middle.val == other.table_number) {
                counter_middle.val = -1;
                other.found_game = true;
            } else if (counter_right.val == other.table_number) {
                counter_right.val = -1;
                other.found_game = true;
            } else {
                //If the game was not found on the counters, search for it in the three 
                //cart queues, going in reverse order (because the game is more likely (essentially
                //always) in the later queues.
                
                //First loop through the 3rd queue. If found, break loop.
                for(i = 0; i &lt; ds_list_size(queue_3); i++) {
                    if(ds_list_find_value(queue_3, i) == other.table_number) {
                        other.found_game = true;
                        break;
                    }
                }
                
                //If did not find the game yet, try the 2nd queue.
                if(!other.found_game) {
                    //Loop through queue 2
                    for(i = 0; i &lt; ds_list_size(queue_2); i++) {
                        if(ds_list_find_value(queue_2, i) == other.table_number) {
                            other.found_game = true;
                            break;
                        }
                    }
                    
                    //If still did not find game, thrid time is a charm, check queue 1
                    if(!other.found_game) {
                        for(i = 0; i &lt; ds_list_size(queue_1); i++) {
                            if(ds_list_find_value(queue_1, i) == other.table_number) {
                                other.found_game = true;
                                break;
                            }
                        }
                    }
                }
            }
        }
        
        //If did not find game on counter or cart queues, then check player hands
        if(!found_game) {
            //In the player object
            with(global.player_id) {
                //If left hand number is the table number
                if(hands_number[0] == other.table_number) {
                    //Empty hands
                    hands[0] = 0;
                    hands_number[0] = 0;
                    other.found_game = true;
                }
                //If the right hand number is the table number
                if(hands_number[1] == other.table_number) {
                    //Empty hands
                    hands[1] = 0;
                    hands_number[1] = 0;
                    other.found_game = true; 
                }
            }
        }
        
        //Show message if still not found game
        if(!found_game) show_debug_message("obj_patron_parent_alarm_2 line 85");
    }
    //Change the table back to empty
    instance_change(obj_table_empty, true);
}

//With our controller run alarm that checks if that was the last patron
with(obj_globals_controler) alarm[3] = 1;

instance_destroy();
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Waiting to give ID
scr_play_sound(snd_ready);
patron_state = patron.hand;

with(table_id) {
    is_waiting = true;
    table_state = 1;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Drag and drop
// If patron is selected, not already seated, and is the only patron picked up
if (selected &amp;&amp; !seated &amp;&amp; global.player_id.picked_up_patron &amp;&amp; !leaving) 
{
    // Move the patron's position to follow the mouse
    x = mouse_x;
    y = mouse_y;

    // Check if released left click
    if (mouse_check_button_released(mb_left)) 
    {
        // If met with only empty table
        if (place_meeting(x, y, obj_table_empty) &amp;&amp; !place_meeting(x, y, obj_table_seated)) 
        {
            // Get the table instance
            table_id = instance_place(x, y, obj_table_empty);
            // With the table
            with(table_id) {
                // Change instance to seated table
                instance_change(obj_table_seated, true);
                if(other.spr_standing == spr_patron_1_glowing) table_items = spr_table_items_glowing;
                // Set seated value
                table_number = global.count_table++;
                num_seated = other.group_size;
                patron_id = other.id;
            }      
                
            //Move patrons to table
            x = table_id.x - 50;
            y = table_id.y + 4;
            
            //Points and happiness script
            scr_points(id, 1);
            
            //First wait alarm
            alarm[1] = room_speed * (wait_time + 0.15);
            // Deselect patron
            selected = false;
            // Flag patron as seated
            seated = true;
            // Set new depth
            depth = -5;
            //Play sound
            scr_play_sound(s_place);
            //Change patron state to be sitting (sprite)
            patron_state = patron.sitting;  
            //Reorder queue alarm
            with(obj_queue) { 
                alarm[1] = 1; 
                patron_to_remove = other.id;
            }
            //Allow for other patrons to be picked up
            global.player_id.picked_up_patron = false;
        // Else if did not meet empty table, deselect and move patron back to original position
        } else  {
            scr_play_sound(s_place);
            selected = false;
            x = orig_x;
            y = orig_y;
            depth = orig_depth;
            //Allow for other patrons to be picked up
            global.player_id.picked_up_patron = false;
        } 
    }
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Happiness
if(happiness == 0 &amp;&amp; !leaving) {
    //Patrons Leave
    global.patrons_lost++;
    alarm[2] = room_speed * 1.5;
    scr_play_sound(snd_leave);
    leaving = true;
} else if (happiness_timer == 0 &amp;&amp; happiness &gt; 0) {
    happiness--;
    happiness_timer = room_speed * happiness_decay;
} else {
    happiness_timer--;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="6" enumb="4">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Selecting patron

//If the patron is not already seated and there isn't already a patron picked up
if(!seated &amp;&amp; !global.player_id.picked_up_patron) {
    //Select the patron
    selected = true;
    //Remember the original coordinates
    orig_x = x;
    orig_y = y;
    //Set the patron the appear ontop of all other objects
    depth = -1000;
    //Play select sound
    scr_play_sound(s_select);
    //Set to prevent multiple patrons from being picked up
    global.player_id.picked_up_patron = true;
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Sprite controller for patron

//Frame/SubImage controller
//If counted the image_speed # of steps
if(spr_image_speed_counter == spr_image_speed) {
    //Increase our subimage of our sprites
    spr_subimage++;
    //Reset the counter to be used again
    spr_image_speed_counter = 0;
    //Makesure subimage doesn't go over possible limit
    if(spr_subimage &gt; 24) spr_subimage = 0;
} else {
    //Else just increase the counter until it reches the condition
    spr_image_speed_counter++;
}

//Use local variables to save on calculation/easy to alter (after seated at table)
if(table_id) {
    var back_left_x = x+5;
    var back_right_x = table_id.x+49;
    var back_y = y-38;
    var front_x = table_id.x+54;
}

//************************** Image controller ********************************
//* Draws according to group size. Then draws according to the player state. *
//* Draws shadows first, then draws each sprite accordingly. Back chairs are *
//* drawn first, then front chairs. X &amp; Y values are offset from the player  *
//* and from the table (which the player is already offset from).            *
//****************************************************************************

//Switch statement for number of patrons in the group
switch(group_size) {
    //1 person in group
    case 1:
        //Given a groupsize, draw according to the state of the patron
        switch(patron_state) {
            case patron.standing:
                image_xscale = 3;
                scr_draw_shadow_ext(spr_standing, spr_subimage, x, y, 1);
                draw_sprite(spr_standing, spr_subimage, x, y);
                break;
            case patron.sitting:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_sitting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_bottom_chair, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_bottom_chair, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.hand:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, x, y, 1);
                draw_sprite(spr_hand_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_bottom_chair, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_bottom_chair, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.waiting:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_waiting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_bottom_chair, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_bottom_chair, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.game:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, x, y, 1);
                draw_sprite(spr_game_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_bottom_chair, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_bottom_chair, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
        }
        break;
    //2 people in group
    case 2:
        //Given a groupsize, draw according to the state of the patron
        switch(patron_state) {
            case patron.standing:
                image_xscale = 3;
                scr_draw_shadow_ext(spr_standing, spr_subimage, x - 10, y, 1);
                draw_sprite(spr_standing, spr_subimage, x - 10, y);
                scr_draw_shadow_ext(spr_standing, spr_subimage, x + 10, y, 1);
                draw_sprite(spr_standing, spr_subimage, x + 10, y);
                break;
            case patron.sitting:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_sitting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_sitting_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.hand:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, x, y, 1);
                draw_sprite(spr_hand_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_hand_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.waiting:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_waiting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_waiting_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.game:
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_top_chair, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, x, y, 1);
                draw_sprite(spr_game_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_game_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
        }
        break;
    //3 people in group
    case 3:
        //Given a groupsize, draw according to the state of the patron
        switch(patron_state) {
            case patron.standing:
                image_xscale = 4;
                scr_draw_shadow_ext(spr_standing, spr_subimage, x-20, y, 1);
                draw_sprite(spr_standing, spr_subimage, x-20, y);
                scr_draw_shadow_ext(spr_standing, spr_subimage, x, y, 1);
                draw_sprite(spr_standing, spr_subimage, x, y);
                scr_draw_shadow_ext(spr_standing, spr_subimage, x + 20, y, 1);
                draw_sprite(spr_standing, spr_subimage, x + 20, y);
                break;
            case patron.sitting:
                scr_draw_shadow_ext(spr_sitting_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_sitting_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_sitting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_sitting_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.hand:
                scr_draw_shadow_ext(spr_hand_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_hand_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, x, y, 1);
                draw_sprite(spr_hand_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_hand_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.waiting:
                scr_draw_shadow_ext(spr_waiting_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_waiting_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_waiting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_waiting_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.game:
                scr_draw_shadow_ext(spr_game_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_game_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_top_chair, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, x, y, 1);
                draw_sprite(spr_game_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_game_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
        }
        break;
    //4 people in group
    case 4:
        //Given a groupsize, draw according to the state of the patron
        switch(patron_state) {
            case patron.standing:
                image_xscale = 5;
                scr_draw_shadow_ext(spr_standing, spr_subimage, x - 30, y, 1);
                draw_sprite(spr_standing, spr_subimage, x - 30, y);
                scr_draw_shadow_ext(spr_standing, spr_subimage, x - 10, y, 1);
                draw_sprite(spr_standing, spr_subimage, x - 10, y);
                scr_draw_shadow_ext(spr_standing, spr_subimage, x + 10, y, 1);
                draw_sprite(spr_standing, spr_subimage, x + 10, y);
                scr_draw_shadow_ext(spr_standing, spr_subimage, x + 30, y, 1);
                draw_sprite(spr_standing, spr_subimage, x + 30, y);
                break;
            case patron.sitting:
                scr_draw_shadow_ext(spr_sitting_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_sitting_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_sitting_back, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_sitting_back, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_sitting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_sitting_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_sitting_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.hand:
                scr_draw_shadow_ext(spr_hand_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_hand_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_hand_back, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_hand_back, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, x, y, 1);
                draw_sprite(spr_hand_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_hand_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_hand_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.waiting:
                scr_draw_shadow_ext(spr_waiting_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_waiting_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_waiting_back, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_waiting_back, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, x, y, 1);
                draw_sprite(spr_waiting_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_waiting_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_waiting_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
            case patron.game:
                scr_draw_shadow_ext(spr_game_back, spr_subimage, back_left_x, back_y, 1);
                draw_sprite(spr_game_back, spr_subimage, back_left_x, back_y);
                
                scr_draw_shadow_ext(spr_game_back, spr_subimage, back_right_x, back_y, -1);
                draw_sprite_ext(spr_game_back, spr_subimage, back_right_x, back_y, -1,1,0,c_white,1);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, x, y, 1);
                draw_sprite(spr_game_front, spr_subimage, x, y);
                
                scr_draw_shadow_ext(spr_game_front, spr_subimage, front_x, y, -1);
                draw_sprite_ext(spr_game_front, spr_subimage, front_x, y, -1,1,0,c_white,1);
                break;
        }
        break;
}
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Draw happiness
//script_execute(scr_draw_shadow);

//If happiness is higher than possible
if(happiness &gt; 6) {
    //Reset happiness and happines_timer to be maximum
    happiness = 6;
    happiness_timer = room_speed * happiness_decay;
}

//Draw happiness event
if(seated){
    draw_sprite(spr_happiness, happiness, table_id.x, table_id.y);
}
else {
    switch(group_size) {
        case 1: 
            draw_sprite(spr_happiness, happiness, x, y);
            break;
        case 2: 
            draw_sprite(spr_happiness, happiness, x, y);
            break;
        case 3: 
            draw_sprite(spr_happiness, happiness, x, y);
            break;
        case 4: 
            draw_sprite(spr_happiness, happiness, x, y);
            break;
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
